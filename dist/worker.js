let e=0;const t=e++,s=e++,r=e++,n=e++,{ArrayBuffer:a,Atomics:o,Promise:c}=globalThis,{isArray:i}=Array,{create:l,getPrototypeOf:f,values:p}=Object,u=f(Int32Array),d=l(o),w=({currentTarget:e,type:t,origin:s,lastEventId:r,source:n,ports:a},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:r,source:n,ports:a})),g=()=>c.withResolvers(),y=new Map,h=(t,s)=>class extends t{constructor(t,...r){super(t,...r),t instanceof s&&y.set(this,[e++,0,g()])}},v=new WeakSet,A=e=>(v.add(e),e),E=(e,s)=>{const{data:r}=e,n=i(r)&&(r.at(0)===s||r.at(1)===t&&!s);return n&&(e.stopImmediatePropagation(),e.preventDefault()),n},m=e=>null!==e&&"object"==typeof e&&!v.has(e),b=new WeakMap,k=(e,t,s)=>{if(y.has(e))t.set(e,y.get(e)[0]);else if(!(e instanceof u||e instanceof a))for(const r of p(e))m(r)&&!s.has(r)&&(s.add(r),k(r,t,s))},T=(...e)=>({value:new c((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),M=(e,t)=>{const s=y.get(e),[r,n,{promise:a}]=s;return s[1]=t,[r,a]};let{BigInt64Array:I,Int32Array:S,SharedArrayBuffer:x,addEventListener:j,postMessage:O}=globalThis,P=e=>e,B=!0;const R=g();try{new x(4),d.waitAsync||(d.waitAsync=T),R.resolve()}catch(e){const{stringify:o}=JSON,c=O,i=j,l=[];let f="",p="";x=class extends a{},I=h(I,x),S=h(S,x),P=A,d.notify=(e,t)=>{const[r]=(e=>b.get(e))(e);return c([f,s,e,r,t]),0},d.waitAsync=(...e)=>{const[t,s]=M(...e);return{value:s}},d.wait=(e,t,...s)=>{const[r]=M(e,t,...s),n=new XMLHttpRequest;n.responseType="json",n.open("POST",`${p}?sabayon`,!1),n.setRequestHeader("Content-Type","application/json"),n.send(o([f,r,t]));const{response:a}=n;y.delete(e);for(let t=0;t<a.length;t++)e[t]=a[t];return"ok"},i("message",(e=>{if(E(e,f)){const[a,o,...c]=e.data;switch(o){case t:f=a,p=c.at(0)?.serviceWorker||"",p||(d.wait=null,R.resolve());break;case s:((e,t,s)=>{for(const[r,[n,a,{resolve:o}]]of y)if(t===n&&s===a){for(let t=0;t<e.length;t++)r[t]=e[t];y.delete(r),o("ok");break}})(...c);break;case r:((e,t,s)=>{for(const[s,r]of t)b.set(s,[r,e.currentTarget]);w(e,s)})(e,...c);break;case n:R.resolve()}}else if(B){const{currentTarget:t,type:s,origin:r,lastEventId:n,source:a,ports:o}=e;l.push([{currentTarget:t,type:s,origin:r,lastEventId:n,source:a,ports:o},e.data])}})),j=(e,...t)=>{if(i(e,...t),l.length)for(const e of l.splice(0))w(...e)},O=(e,...t)=>c(((e,t)=>{const s=new Map;return m(t)&&k(t,s,new Set),s.size?[e,r,s,t]:t})(f,e),...t)}await R.promise,B=!1;const{BYTES_PER_ELEMENT:W}=Int32Array,{BYTES_PER_ELEMENT:D}=Uint16Array,{notify:L}=d,{entries:N}=Object,_=new TextDecoder("utf-16"),U=new WeakSet,q=(...e)=>(U.add(e),e),C=new Map;let H=0;const J=([e,t,n,a,o,c,i,l],f)=>(...p)=>{const u=H++,d=[];U.has(p.at(-1)||d)&&U.delete(d=p.pop());const w=o(i?p.map(i):p);let g=new t(new n(2*W));return a([e,r,u,g,f,w],{transfer:d}),l(g,0).value.then((()=>{const r=g[1];if(!r)return;const o=D*r;return g=new t(new n(o+o%W)),a([e,s,u,g]),l(g,0).value.then((()=>c(_.decode(new Uint16Array(g.buffer).slice(0,r)))))}))},Y=(e,t)=>{const s=new Map;for(const[r,n]of N(t))s.set(r,e.push(n)-1);return s},z=(e,t)=>{const s={};for(const[r,n]of t)s[r]=J(e,n);return s},{wait:X,waitAsync:$}=d;var F=({interrupt:e,parse:n,stringify:a,transform:o}=JSON)=>{const c=((e,t)=>async(s,r,n,a)=>{try{const o=await s(...a);if(void 0!==o){const s=e(t?t(o):o);C.set(r,s),n[1]=s.length}}finally{n[0]=1,L(n,0)}})(a,o),i=g(),l=[];let f="",p=X;if(X&&e){const{handler:t,timeout:s=42}=e;p=(e,r,n)=>{for(;"timed-out"===(n=X(e,r,0,s));)t();return n}}return j("message",(e=>{if(E(e,f)){const[a,u,...d]=e.data;switch(u){case t:f=a,i.resolve({transfer:q,proxy:z([f,S,x,O,P,n,o,X?(...e)=>({value:{then:t=>t(p(...e))}}):$],d[0].exports),exports(e){O(P([f,t,Y(l,e)]))}});break;case r:{const[e,t,s,r]=d;c(l[s],e,t,r);break}case s:((e,t)=>{const s=C.get(e);C.delete(e);for(let e=new Uint16Array(t.buffer),r=0,{length:n}=s;r<n;r++)e[r]=s.charCodeAt(r);L(t,0)})(...d)}}})),i.promise};export{F as default};
