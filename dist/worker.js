const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:r}=Array,{create:n,getPrototypeOf:a,values:o}=Object,c=a(Int32Array),i=n(t),l=({currentTarget:e,type:t,origin:s,lastEventId:r,source:n,ports:a},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:r,source:n,ports:a})),f=()=>s.withResolvers();let p=0;const u=new Map,d=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&u.set(this,[p++,0,f()])}},w=new WeakSet,g=e=>(w.add(e),e),y=(e,t)=>{const{data:s}=e,n=r(s)&&(s.at(0)===t||0===s.at(1)&&!t);return n&&(e.stopImmediatePropagation(),e.preventDefault()),n},h=e=>null!==e&&"object"==typeof e&&!w.has(e),v=new WeakMap,E=(t,s,r)=>{if(u.has(t))s.set(t,u.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of o(t))h(e)&&!r.has(e)&&(r.add(e),E(e,s,r))},A=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),k=(e,t)=>{const s=u.get(e),[r,n,{promise:a}]=s;return s[1]=t,[r,a]};let{BigInt64Array:m,Int32Array:T,SharedArrayBuffer:b,addEventListener:M,postMessage:I}=globalThis,S=e=>e,x=!0;const P=f();try{new b(4),i.waitAsync||(i.waitAsync=A),P.resolve()}catch(t){const{stringify:s}=JSON,r=I,n=M,a=[];let o="",c="";b=class extends e{},m=d(m,b),T=d(T,b),S=g,i.notify=(e,t)=>{const[s]=(e=>v.get(e))(e);return r([o,1,e,s,t]),0},i.waitAsync=(...e)=>{const[t,s]=k(...e);return{value:s}},i.wait=(e,t,...r)=>{const[n]=k(e,t,...r),a=new XMLHttpRequest;a.responseType="json",a.open("POST",`${c}?sabayon`,!1),a.setRequestHeader("Content-Type","application/json"),a.send(s([o,n,t]));const{response:i}=a;u.delete(e);for(let t=0;t<i.length;t++)e[t]=i[t];return"ok"},n("message",(e=>{if(y(e,o)){const[t,s,...r]=e.data;switch(s){case 0:o=t,c=r.at(0)?.serviceWorker||"",c||(i.wait=null,P.resolve());break;case 1:((e,t,s)=>{for(const[r,[n,a,{resolve:o}]]of u)if(t===n&&s===a){for(let t=0;t<e.length;t++)r[t]=e[t];u.delete(r),o("ok");break}})(...r);break;case 2:((e,t,s)=>{for(const[s,r]of t)v.set(s,[r,e.currentTarget]);l(e,s)})(e,...r);break;case 3:P.resolve()}}else if(x){const{currentTarget:t,type:s,origin:r,lastEventId:n,source:o,ports:c}=e;a.push([{currentTarget:t,type:s,origin:r,lastEventId:n,source:o,ports:c},e.data])}})),M=(e,...t)=>{if(n(e,...t),a.length)for(const e of a.splice(0))l(...e)},I=(e,...t)=>r(((e,t)=>{const s=new Map;return h(t)&&E(t,s,new Set),s.size?[e,2,s,t]:t})(o,e),...t)}await P.promise,x=!1;const{BYTES_PER_ELEMENT:j}=Int32Array,{BYTES_PER_ELEMENT:B}=Uint16Array,{notify:D}=i,O=new TextDecoder("utf-16"),R=new WeakSet,W=(...e)=>(R.add(e),e);let L=0;const N=new Map;let U=0;const _=(e,t)=>new Proxy(t,{get:(t,s)=>t.get(s)||t.set(s,(([e,t,s,r,n,a,o,c],i)=>(...l)=>{if(L)throw new Error(`ðŸ’€ðŸ”’ - Deadlock on proxy.${i}()`);const f=U++,p=[];R.has(l.at(-1)||p)&&R.delete(p=l.pop());const u=n(o?l.map(o):l);let d=new t(new s(2*j));return r([e,2,f,d,i,u],{transfer:p}),c(d,0).value.then((()=>{const n=d[1];if(!n)return;const o=B*n;return d=new t(new s(o+o%j)),r([e,1,f,d]),c(d,0).value.then((()=>a(O.decode(new Uint16Array(d.buffer).slice(0,n)))))}))})(e,s)).get(s),set:(e,t,s)=>!!e.set(t,s)}),{wait:$,waitAsync:q}=i;var C=({interrupt:e,parse:t,stringify:s,transform:r}=JSON)=>{const n=((e,t)=>async(s,r,n,a)=>{try{L++;const o=await s(...a);if(void 0!==o){const s=e(t?t(o):o);N.set(r,s),n[1]=s.length}}finally{L--,n[0]=1,D(n,0)}})(s,r),a=f(),o=new Map;let c="",i=$;if($&&e){const{handler:t,timeout:s=42}=e;i=(e,r,n)=>{for(;"timed-out"===(n=$(e,r,0,s));)t();return n}}return M("message",(e=>{if(y(e,c)){const[s,l,...f]=e.data;switch(l){case 0:c=s,a.resolve({transfer:W,proxy:_([c,T,b,I,S,t,r,$?(...e)=>({value:{then:t=>t(i(...e))}}):q],o)});break;case 2:((e,t,[s,r,n,a])=>{const o=t.get(n);if(!o)throw new Error(`Unknown proxy.${n}()`);e(o,s,r,a)})(n,o,f);break;case 1:((e,t)=>{const s=N.get(e);N.delete(e);for(let e=new Uint16Array(t.buffer),r=0,{length:n}=s;r<n;r++)e[r]=s.charCodeAt(r);D(t,0)})(...f)}}})),a.promise};export{C as default};
