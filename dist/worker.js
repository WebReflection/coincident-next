const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:r}=Array,{create:n,getPrototypeOf:a,values:o}=Object,c=a(Int32Array),i=n(t),l=({currentTarget:e,type:t,origin:s,lastEventId:r,source:n,ports:a},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:r,source:n,ports:a})),f=()=>s.withResolvers();let p=0;const u=new Map,d=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&u.set(this,[p++,0,f()])}},w=new WeakSet,g=e=>(w.add(e),e),y=(e,t)=>{const{data:s}=e,n=r(s)&&(s.at(0)===t||0===s.at(1)&&!t);return n&&(e.stopImmediatePropagation(),e.preventDefault()),n},h=e=>null!==e&&"object"==typeof e&&!w.has(e),v=new WeakMap,A=(t,s,r)=>{if(u.has(t))s.set(t,u.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of o(t))h(e)&&!r.has(e)&&(r.add(e),A(e,s,r))},E=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),m=(e,t)=>{const s=u.get(e),[r,n,{promise:a}]=s;return s[1]=t,[r,a]};let{BigInt64Array:b,Int32Array:k,SharedArrayBuffer:T,addEventListener:M,postMessage:I}=globalThis,S=e=>e,x=!0;const j=f();try{new T(4),i.waitAsync||(i.waitAsync=E),j.resolve()}catch(t){const{stringify:s}=JSON,r=I,n=M,a=[];let o="",c="";T=class extends e{},b=d(b,T),k=d(k,T),S=g,i.notify=(e,t)=>{const[s]=(e=>v.get(e))(e);return r([o,1,e,s,t]),0},i.waitAsync=(...e)=>{const[t,s]=m(...e);return{value:s}},i.wait=(e,t,...r)=>{const[n]=m(e,t,...r),a=new XMLHttpRequest;a.responseType="json",a.open("POST",`${c}?sabayon`,!1),a.setRequestHeader("Content-Type","application/json"),a.send(s([o,n,t]));const{response:i}=a;u.delete(e);for(let t=0;t<i.length;t++)e[t]=i[t];return"ok"},n("message",(e=>{if(y(e,o)){const[t,s,...r]=e.data;switch(s){case 0:o=t,c=r.at(0)?.serviceWorker||"",c||(i.wait=null,j.resolve());break;case 1:((e,t,s)=>{for(const[r,[n,a,{resolve:o}]]of u)if(t===n&&s===a){for(let t=0;t<e.length;t++)r[t]=e[t];u.delete(r),o("ok");break}})(...r);break;case 2:((e,t,s)=>{for(const[s,r]of t)v.set(s,[r,e.currentTarget]);l(e,s)})(e,...r);break;case 3:j.resolve()}}else if(x){const{currentTarget:t,type:s,origin:r,lastEventId:n,source:o,ports:c}=e;a.push([{currentTarget:t,type:s,origin:r,lastEventId:n,source:o,ports:c},e.data])}})),M=(e,...t)=>{if(n(e,...t),a.length)for(const e of a.splice(0))l(...e)},I=(e,...t)=>r(((e,t)=>{const s=new Map;return h(t)&&A(t,s,new Set),s.size?[e,2,s,t]:t})(o,e),...t)}await j.promise,x=!1;const{BYTES_PER_ELEMENT:O}=Int32Array,{BYTES_PER_ELEMENT:P}=Uint16Array,{notify:B}=i,{entries:R}=Object,W=new TextDecoder("utf-16"),D=new WeakSet,L=(...e)=>(D.add(e),e),N=new Map;let _=0;const U=([e,t,s,r,n,a,o,c],i)=>(...l)=>{const f=_++,p=[];D.has(l.at(-1)||p)&&D.delete(p=l.pop());const u=n(o?l.map(o):l);let d=new t(new s(2*O));return r([e,2,f,d,i,u],{transfer:p}),c(d,0).value.then((()=>{const n=d[1];if(!n)return;const o=P*n;return d=new t(new s(o+o%O)),r([e,1,f,d]),c(d,0).value.then((()=>a(W.decode(new Uint16Array(d.buffer).slice(0,n)))))}))},q=(e,t)=>{const s=new Map;for(const[r,n]of R(t))s.set(r,e.push(n)-1);return s},C=(e,t)=>{const s={};for(const[r,n]of t)s[r]=U(e,n);return s},{wait:H,waitAsync:J}=i;var Y=({interrupt:e,parse:t,stringify:s,transform:r}=JSON)=>{const n=((e,t)=>async(s,r,n,a)=>{try{const o=await s(...a);if(void 0!==o){const s=e(t?t(o):o);N.set(r,s),n[1]=s.length}}finally{n[0]=1,B(n,0)}})(s,r),a=f(),o=[];let c="",i=H;if(H&&e){const{handler:t,timeout:s=42}=e;i=(e,r,n)=>{for(;"timed-out"===(n=H(e,r,0,s));)t();return n}}return M("message",(e=>{if(y(e,c)){const[s,l,...f]=e.data;switch(l){case 0:c=s,a.resolve({transfer:L,proxy:C([c,k,T,I,S,t,r,H?(...e)=>({value:{then:t=>t(i(...e))}}):J],f[0].exports),exports(e){I(S([c,0,q(o,e)]))}});break;case 2:{const[e,t,s,r]=f;n(o[s],e,t,r);break}case 1:((e,t)=>{const s=N.get(e);N.delete(e);for(let e=new Uint16Array(t.buffer),r=0,{length:n}=s;r<n;r++)e[r]=s.charCodeAt(r);B(t,0)})(...f)}}})),a.promise};export{Y as default};
